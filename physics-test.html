<!doctype html>
<html lang="en">
    <head>
        <title>Three.js/Ammo.js Quake 3 Physics Test</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #FFFFFF;
                font-family:Monospace;
                font-size:13px;
                text-align:center;

                background-color: #000000;
                margin: 0px;
                overflow: hidden;
            }

            a { color: #a06851; }

            #info {
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
            }
        </style>
    </head>
    <body>

        <div id="container"><br /><br /><br /><br /><br />Loading world...</div>

        <script src="js/ammo.js"></script>

        <script src="js/threejs/Three.js"></script>
        <script src="js/threejs/Detector.js"></script>
        <script src="js/threejs/Stats.js"></script>

        <script>

            if (!Detector.webgl ) {

                Detector.addGetWebGLMessage();
                document.getElementById('container').innerHTML = "";

            }

            var container, stats;

            var camera, controls, scene, renderer;

            var mesh, mat;

            var clock = new THREE.Clock();

            var timeUniform = { type: "f", value: 1.0 };

            var dynamicsWorld;
            var bulletMaterials;

            var physicsMeshCallbacks = [];

            init();
            animate();

            function init() {

                container = document.getElementById( 'container' );

                scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 20000 );
                scene.add( camera );

                controls = new THREE.FirstPersonControls( camera );

                controls.movementSpeed = 500;
                controls.lookSpeed = 0.125;
                controls.lookVertical = true;

                var ambientLight = new THREE.AmbientLight( 0x222222 );
                scene.add( ambientLight );

                var directionalLight = new THREE.DirectionalLight( 0xffffff, 2 );
                directionalLight.position.set( 1, 1, 0.5 ).normalize();
                scene.add( directionalLight );

                renderer = new THREE.WebGLRenderer( { clearColor: 0x010101 } );
                renderer.setSize( window.innerWidth, window.innerHeight );

                container.innerHTML = "";

                container.appendChild( renderer.domElement );

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                container.appendChild( stats.domElement );


                bulletMaterials = [
                    new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: THREE.ImageUtils.loadTexture( 'demo_baseq3/textures/sfx/metalbridge06_bounce.png' ) } ),
                    new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true, transparent: true, opacity: 0.1 } )
                ];
                
                loadQuake3Map("root", "q3dm1");
                camera.position.set(640, 100, -512);

                //loadQuake3Map("export", "q3tourney2");
                //loadQuake3Map("export", "phantq3dm4");
                //loadQuake3Map("export", "solitude");
            }

            function loadQuake3Map(baseUrl, name) {
                var loader = new THREE.JSONLoader();
                loader.load(baseUrl + "/" + name + ".json", function( geometry ) {
                    initMaterials(baseUrl + "/" + name + ".materials.json", baseUrl, function(materials) {
                        geometry.materials = materials;
                        var mesh = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial() );
                        scene.add( mesh );
                    });
                });

                initPhysics(baseUrl + "/" + name + ".collision.json");
            }

            function initMaterials(url, baseUrl, callback) {
                var request = new XMLHttpRequest();
    
                request.addEventListener("load", function () {
                    var materials = JSON.parse(request.responseText);
                    var matList = buildMaterialList(materials, baseUrl);
                    callback(matList);
                }, false);
                
                request.open('GET', url, true);
                request.setRequestHeader('Content-Type', 'text/json');
                request.send(null);
            }

            function buildMaterialList(materials, baseUrl) {
                var i, matList = [];

                for(i in materials) {
                    matList.push(materialToShader(materials[i], baseUrl));
                }

                return matList;
            }

            function materialToShader(material, baseUrl) {
                var i, uniform, src, uniforms = {};

                for(i in material.uniforms) {
                    uniform = material.uniforms[i];

                    if(i == "time" && uniform.type == "f") {
                        uniform = timeUniform;
                    }
                    
                    if(uniform.type == "t") {
                        if(uniform.animTexture) {
                            src = uniform.animTexture[0];
                        } else {
                            src = uniform.texture;
                        }
                        
                        uniform.texture = THREE.ImageUtils.loadTexture( baseUrl + "/" + src );
                        uniform.texture.wrapS = uniform.texture.wrapT = uniform.clamp ? THREE.ClampToEdgeWrapping : THREE.RepeatWrapping;
                    }

                    uniforms[i] = uniform;
                }

                var threeMaterial = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexColors: true,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                });

                if(material.blend) {
                    threeMaterial.transparent = true;
                    threeMaterial.blending = THREE.CustomBlending;
                    threeMaterial.blendEquation = THREE.AddEquation;
                    threeMaterial.blendSrc = THREE[material.blendSrc];
                    threeMaterial.blendDst = THREE[material.blendDst];
                } else {
                    threeMaterial.transparent = false;
                    threeMaterial.blending = THREE.NoBlending;
                }

                return threeMaterial;
            }

            function initPhysics(url) {
                var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
                var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
                var overlappingPairCache = new Ammo.btDbvtBroadphase();
                var solver = new Ammo.btSequentialImpulseConstraintSolver();
                dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
                dynamicsWorld.setGravity(new Ammo.btVector3(0, -100, 0));
                var request = new XMLHttpRequest();
                
                request.addEventListener("load", function () {
                    var hulls = JSON.parse(request.responseText);
                    var matList = buildCollisionHulls(hulls);
                }, false);
                
                request.open('GET', url, true);
                request.setRequestHeader('Content-Type', 'text/json');
                request.send(null);
            }

            function buildCollisionHulls(hulls) {
                var i, j, hull;

                var levelShape = new Ammo.btCompoundShape();

                var transform = new Ammo.btTransform();
                transform.setIdentity();

                for(i in hulls) {
                    hull = hulls[i];
                    var shape = new Ammo.btConvexHullShape();
                    for(j = 0; j < hull.length; j+=3) {
                        shape.addPoint(new Ammo.btVector3(hull[j], hull[j+1], hull[j+2]));
                    }

                    levelShape.addChildShape(transform, shape);
                }
                
                var mass = 0;
                var localInertia = new Ammo.btVector3(0, 0, 0);
                var motionState = new Ammo.btDefaultMotionState(transform);
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(0, motionState, levelShape, localInertia);
                var body = new Ammo.btRigidBody(rigidBodyInfo);

                dynamicsWorld.addRigidBody(body);
            }

            function addBox() {
                var pos = camera.position.clone();
                var rot = new THREE.Quaternion();
                rot.setFromEuler(camera.rotation);

                var shape = new Ammo.btBoxShape(new Ammo.btVector3(5, 5, 5));
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));

                var mass = 1;
                var localInertia = new Ammo.btVector3(0, 0, 0);
                shape.calculateLocalInertia(mass, localInertia);

                var motionState = new Ammo.btDefaultMotionState(transform);
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                var body = new Ammo.btRigidBody(rigidBodyInfo);
                dynamicsWorld.addRigidBody(body);

                body.activate();

                pos.negate();
                var dir = pos.addSelf(controls.target);
                dir.multiplyScalar(200); // speed of launch
                body.applyCentralForce(new Ammo.btVector3(dir.x, dir.y, dir.z));

                var object = THREE.SceneUtils.createMultiMaterialObject( new THREE.CubeGeometry( 10, 10, 10, 1, 1, 1 ), bulletMaterials );
                object.position.set(pos.x, pos.y, pos.z);
                object.useQuaternion = true;
                scene.add(object);

                physicsMeshCallbacks.push(function() {
                    body.getMotionState().getWorldTransform(transform);

                    var origin = transform.getOrigin();
                    object.position.set(origin.x(), origin.y(), origin.z());

                    var rotation = transform.getRotation();
                    object.quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w());
                });

                return body;
            }

            document.addEventListener("keydown", function(event) {
                if(event.keyCode == 32) {
                    addBox();
                }
            }, false);

            function updatePhysicsMeshes() {
                var i;
                for(i in physicsMeshCallbacks) {
                    physicsMeshCallbacks[i]();
                }
            }

            function animate() {
                requestAnimationFrame( animate );

                render();
                stats.update();
            }

            function render(delta) {
                var delta = clock.getDelta();
                timeUniform.value += delta;

                dynamicsWorld.stepSimulation(delta, 2);
                updatePhysicsMeshes();

                controls.update( delta );
                renderer.render( scene, camera );
            }

        </script>

    </body>
</html>
